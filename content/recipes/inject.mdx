---
name: Injecting stores
menu: Recipes
---

# ~~Injecting~~ Accessing stores

The term of injection comes from `mobx-react` library. It is a legacy way of accessing the MobX stores across component tree. The previous version of [React context][context-article] was rather awkward to use, these utilities were made to smoothen things up.

We are in 2019 now and we don't need injections anymore (_kids, don't do drugs_). For the sake of easy transition, this term is mentioned here, but consider it obsolete. **But why? ([see below](#why-is-inject-obsolete))**

## Welcome to React Context

Let's make a small, but not so contrived example to show some nice approach.

### Create store

Let's declare a simple store. No need to worry about observables at this point, it's just a plain object.

```tsx
export type TFriend = {
  name: string
  isFavorite: boolean
  isSingle: boolean
}

export function createStore() {
  // storing variable in closure means you can access it in methods
  // otherwise you would have to use `this` which doesn't work well with TypeScript
  const store = {
    friends: [] as TFriend[]
    makeFriend(name, isFavorite = false, isSingle = false) {
      const oldFriend = store.friends.find(friend => friend.name === name)
      if (oldFriend) {
        oldFriend.isFavorite = isFavorite
        oldFriend.isSingle = isSingle
      } else {
        store.friends.push({ name, isFavorite, isSingle })
      }
    },
    get singleFriends() {
      return store.friends.filter(friend => friend.isSingle)
    },
  }
  return store
}

export type TStore = ReturnType<typeof createStore>
```

### Setup context

Nothing spectacular about it really, better to read [React docs](context) if you are unsure though.

```tsx
import React from 'react'
import { createStore, TStore } from './createStore'
import { useLocalStore } from 'mobx-react-lite'

const storeContext = React.createContext<TStore | null>(null)

export const StoreProvider = ({ children }) => {
  const store = useLocalStore(createStore)
  return <storeContext.Provider value={store}>{children}</storeContext.Provider>
}

export const useStore = () => {
  const store = React.useContext(storeContext)
  if (!store) {
    // this is especially useful in TypeScript so you don't need to be checking for null all the time
    throw new Error('You have forgot to use StoreProvider, shame on you.')
  }
  return store
}
```

> You could drop a whole Provider dance and set created store as a default value of the `createContext`. The reference of the store object does not need to change, so it will work in most cases. However, you might still setup a Provider for tests to battle flakiness.

### Making friends

Now somewhere in the tree we have component like this.

```tsx
import React from 'react'
import { useStore } from '../../../store'

export const FriendsMaker = observer(() => {
  const store = useStore()
  const onSubmit = React.useCallback(({ name, favorite, single }) => {
    store.makeFriend(name, favorite, single)
  }, [])
  return (
    <Form onSubmit={onSubmit}>
      Total friends: {store.friends.length}
      <input type="text" id="name" />
      <input type="checkbox" id="favorite" />
      <input type="checkbox" id="single" />
    </Form>
  )
})
```

_Explicit implementation of form logic would take up too much space and is not important for the show case._

### Listing friends

In some other part of the app we want to show friends that are single and favorite.

```tsx
import React from 'react'
import { useStore } from '../../../../store'

export const MatchMaker = observer(() => {
  const store = useStore()
  // for a sake of example filtering is done here
  // you might as well expose it on the store directly
  const singleAndFavoriteFriends = store.singleFriends.filter(
    friend => friend.isFavorite,
  )
  return <div>{singleAndFavoriteFriends.map(renderFriend)}</div>
})
```

## Complex stores

The example above is still fairly contrived. Usually the app state is much more robust. It's completely up to you how you will assemble it together.

Perhaps you want to consider [mobx-state-tree] for declaring store shape? It comes with other powerful features like snapshots and type safety out of box. Be sure to check it out.

Either way, the power of Hooks allows you to create specific hooks, eg. `useFriendsList` or `useOrderCart` that grabs only a part of the whole store. Or it can mix two separate segments together if it's desired.

Specific hooks are also great for mitigating long paths in bigger folder structure like seen in examples above.

## Why is inject obsolete?

You might argue that `inject` HOC isn't just a dumb "give me a store" tool. Yes, it also allows reactive selections over the store and pick values the component is interested in.

Have it occured to you it might be for a legacy reasons?

import { Emoji } from '../components'

> No example? Well, it's a legacy pattern, it doesn't deserve one. <Emoji>ðŸ˜†</Emoji>
>
> We don't want to confuse you more than necessary. Have a look at [example from old docs][inject] if you want though.

The "problem" of HOC is they can only pass props to wrapped component. This is where the term **inject** originated as you are really _injecting props_ into a component that weren't there originally.

Whenever observable value in the `inject` selection changes, it can re-render underlying component with new props. That's truly handy, but as you can see above, we can achieve same with less ceremony. As long as you have observer in place, there is no need to worry about this part.

But...but...**mixing state with a component UI is bad practice**, right? Well, nobody is forcing you to do that. You might as well have a component that does MobX stuff only and renders the UI component in the end. It's not that different from HOC approach except it's more explicit.

[context]: https://reactjs.org/docs/context.html
[context-article]: https://markpollmann.com/react-context/
[mobx-state-tree]: https://github.com/mobxjs/mobx-state-tree
[inject]: https://github.com/mobxjs/mobx-react/tree/20ed293a38a7212a2ff66de7639ce0c79aa911c0#customizing-inject
